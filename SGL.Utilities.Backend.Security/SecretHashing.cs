using Microsoft.AspNetCore.Identity;
using Microsoft.Extensions.Options;
using System;

namespace SGL.Utilities.Backend.Security {
	/// <summary>
	/// Centralizes hashing for user secrets to simplify change.
	/// </summary>
	/// <remarks>
	/// To avoid writing our own implementation of hashing and the related encoding or decoding, which might introduce very critical and subtile bugs,
	/// we instead use the PasswordHasher from ASP.Net Core's Identity library which is widely used and mature.
	/// As the PasswordHasher doesn't actually access the user object it is passed, we simplify usage by passing a DummyUser object.
	/// All required data (e.g. salt, algo, iteration count) for a hashed password are encoded in the hased password string itself,
	/// hence no access to the user object is needed and we can avoid passing it through.
	///
	/// To further simplify usage, we provide the options statically from here:
	/// For the compatibility mode, we use the current default coming from Identity.
	/// The IterationCount is 10 times the default value. At the time of writing, the default is 10000 and we thus use 100000.
	/// </remarks>
	public static class SecretHashing {
		private static readonly IOptions<PasswordHasherOptions> options = Options.Create(new PasswordHasherOptions() { IterationCount = 10 * (new PasswordHasherOptions().IterationCount) });
		private class DummyUser { }
		private static readonly DummyUser dummyUser = new DummyUser();

		/// <summary>
		/// Creates an encoded hashed and salted secret, also containing associated parameters (like the salt), from the given plaintext secret.
		/// </summary>
		/// <param name="plainSecret">A user secret (equivalent to a password) in plaintext form.</param>
		/// <returns>An encoded string containing the hashed secret, as well as all parameters needed for verification.</returns>
		public static string CreateHashedSecret(string plainSecret) {
			var hasher = new PasswordHasher<DummyUser>(options);
			return hasher.HashPassword(dummyUser, plainSecret);
		}

		/// <summary>
		/// Checks validity of a given secret against an existing hashed secret, the result of which is indicated by the first return value.
		/// Additionally, if the given secret is valid, but the hashed secret uses outdated parameters, the hashed secret is updated, which is indicated by the second return value being true.
		/// The caller then needs to update the user storage with the new hashed secret.
		/// </summary>
		/// <param name="hashedSecret">An encoded string containing the hashed secret, as well as all parameters needed for verification, as generated by <see cref="CreateHashedSecret"/>.</param>
		/// <param name="plainProvidedSecret">A plaintext secret, supplied for the current login attempt, the validity of which is to be checked.</param>
		/// <returns>
		/// A tuple, consisting of two bools, where the first one indicates whether the provided secret is correct and
		/// where the second one is true in addition to the first one, if the hashed secret needed to be rehashed to update cryptographic parameters.
		/// The combination (false, true) is impossible, because rehashing is only possible, if the valid secret was given, because the plaintext secret is needed for rehashing.
		/// </returns>
		public static (bool valid, bool rehashed) VerifyHashedSecret(ref string hashedSecret, string plainProvidedSecret) {
			var hasher = new PasswordHasher<DummyUser>(options);
			var result = hasher.VerifyHashedPassword(dummyUser, hashedSecret, plainProvidedSecret);
			switch (result) {
				case PasswordVerificationResult.Failed:
					return (false, false);
				case PasswordVerificationResult.Success:
					return (true, false);
				case PasswordVerificationResult.SuccessRehashNeeded:
					hashedSecret = CreateHashedSecret(plainProvidedSecret);
					return (true, true);
				default:
					throw new NotImplementedException("Unexpected result from PasswordHasher.");
			}
		}
	}
}
