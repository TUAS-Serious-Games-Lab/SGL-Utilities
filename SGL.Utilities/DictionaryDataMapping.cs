using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace SGL.Analytics.Utilities {
	/// <summary>
	/// Provides an utility method <see cref="ToDataMappingDictionary(object)"/> that allows mapping POD objects to JSON-like <c><![CDATA[Dictionary<string, object?>]]></c>s.
	/// </summary>
	public static class DictionaryDataMapping {
		private readonly static MethodInfo dictToMappingDict =
			typeof(DictionaryDataMapping).GetMethod(nameof(dictToMappingDictionary), BindingFlags.NonPublic | BindingFlags.Static) ??
				throw new MissingMethodException(nameof(DictionaryDataMapping), nameof(dictToMappingDictionary));

		private static object dictToMappingDictionary<K, V>(IDictionary<K, V> dict) {
			return dict.ToDictionary(kvp => objectToDataMappingKey(kvp.Key) ?? "null", kvp => objectToDataMapping(kvp.Value));
		}
		private static bool isDict(Type type, out Type iface) {
			iface = type;
			var ifaces = type.GetInterfaces().Where(iface => iface.IsGenericType && iface.GetGenericTypeDefinition() == typeof(IDictionary<,>));
			if (ifaces.Count() == 0) return false;
			iface = ifaces.Single();
			return true;
		}

		private static string objectToDataMappingKey(object? obj) {
			switch (obj) {
				case null:
					return "null";
				case DateTime dt:
					return dt.ToString("O");
				default:
					return obj?.ToString() ?? "null";
			}
		}

		private static object? objectToDataMapping(object? obj) {
			Type type = obj?.GetType() ?? typeof(object);
			switch (obj) {
				case null:
				case string:
				case DateTime:
				case TimeSpan:
				case Guid:
				case Enum:
				case object when type.IsPrimitive:
					return obj;
				case Uri:
					return obj.ToString();
				case IDictionary<string, object?> dict:
					return dict;
				case IList<object?> list:
					return list;
				case object when isDict(type, out var iface):
					return dictToMappingDict.MakeGenericMethod(iface.GenericTypeArguments).Invoke(null, new object[] { obj });
				case IEnumerable<object?> e:
					return e.Select(elem => objectToDataMapping(elem)).ToList();
				case object when type.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy).Count() > 0:
					return ToDataMappingDictionary(obj);
				default:
					throw new InvalidOperationException($"Don't know how to map type {type.Name}.");
			}
		}
		/// <summary>
		/// Maps the given POD object to a JSON-like <c><![CDATA[Dictionary<string, object?>]]></c>.
		/// </summary>
		/// <param name="obj">The POD object to map the data from.</param>
		/// <returns>A <c><![CDATA[Dictionary<string, object?>]]></c> that contains the data of the input object.</returns>
		/// <remarks>
		/// In general, the mapping process generates a map entry for each public non-static property of the object.
		/// The keys in the dictionary are the names of the properties.
		/// For properties with semantically primitive types (numeric types, booleans, <c>string</c>, <c>DateTime</c>, <c>TimeSpan</c>, <c>Guid</c>, <c>Uri</c> and enum types) the values are used as-is.
		/// For list/enumerable-typed properties, the value is a list of the results of recursively applying the mapping process to each element.
		/// For dictionary-typed properties, the value is a <c><![CDATA[Dictionary<string, object?>]]></c> where the key are generated by converting the original keys to strings and the values are the results of recursively applying the mapping process to the corresponding original values.
		/// For other complex POD-typed properties, i.e. for properties of types with public properties, the values are the results of recursively applying the mapping process to the property values.
		/// </remarks>
		public static Dictionary<string, object?> ToDataMappingDictionary(object obj) {
			var type = obj.GetType();
			var props = type.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);
			return props.ToDictionary(pi => pi.Name, pi => objectToDataMapping(pi.GetValue(obj)));
		}
	}
}
