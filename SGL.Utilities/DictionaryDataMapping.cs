using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace SGL.Utilities {
	/// <summary>
	/// Provides an utility method <see cref="ToDataMappingDictionary(object)"/> that allows mapping POD objects to JSON-like <c><![CDATA[Dictionary<string, object?>]]></c>s.
	/// </summary>
	public static class DictionaryDataMapping {
		private readonly static MethodInfo dictToMappingDict =
			typeof(DictionaryDataMapping).GetMethod(nameof(DictToMappingDictionary), BindingFlags.NonPublic | BindingFlags.Static) ??
				throw new MissingMethodException(nameof(DictionaryDataMapping), nameof(DictToMappingDictionary));

		private static object DictToMappingDictionary<K, V>(IDictionary<K, V> dict) {
			return dict.ToDictionary(kvp => ObjectToDataMappingKey(kvp.Key) ?? "null", kvp => ObjectToDataMapping(kvp.Value));
		}
		private static bool IsDict(Type type, out Type iface) {
			iface = type;
			var ifaces = type.GetInterfaces().Where(iface => iface.IsGenericType && iface.GetGenericTypeDefinition() == typeof(IDictionary<,>));
			if (!ifaces.Any()) return false;
			iface = ifaces.Single();
			return true;
		}

		private static string ObjectToDataMappingKey(object? obj) => obj switch {
			null => "null",
			DateTime dt => dt.ToString("O"),
			_ => obj?.ToString() ?? "null",
		};

		private static object? ObjectToDataMapping(object? obj) {
			Type type = obj?.GetType() ?? typeof(object);
			switch (obj) {
				case null:
				case string:
				case DateTime:
				case TimeSpan:
				case Guid:
				case Enum:
				case object when type.IsPrimitive:
					return obj;
				case Uri:
					return obj.ToString();
				case IDictionary<string, object?> dict:
					return dict;
				case IList<object?> list:
					return list;
				case object when IsDict(type, out var iface):
					return dictToMappingDict.MakeGenericMethod(iface.GenericTypeArguments).Invoke(null, new object[] { obj });
				case IEnumerable<object?> e:
					return e.Select(elem => ObjectToDataMapping(elem)).ToList();
				case object when type.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy).Length > 0:
					return ToDataMappingDictionary(obj);
				default:
					throw new InvalidOperationException($"Don't know how to map type {type.Name}.");
			}
		}

		/// <summary>
		/// Maps the given POD object to a JSON-like <c><![CDATA[Dictionary<string, object?>]]></c>.
		/// </summary>
		/// <param name="obj">The POD object to map the data from.</param>
		/// <param name="topLevelPropertyFilter">
		/// A function that filters the properties of the top-level object given in <paramref name="obj"/>.
		/// Only the properties for which this function returns true are included.
		/// </param>
		/// <returns>A <c><![CDATA[Dictionary<string, object?>]]></c> that contains the data of the input object.</returns>
		/// <remarks>
		/// In general, the mapping process generates a map entry for each public non-static property of the object.
		/// The keys in the dictionary are the names of the properties.
		/// For properties with semantically primitive types (numeric types, booleans, <c>string</c>, <c>DateTime</c>, <c>TimeSpan</c>, <c>Guid</c>, <c>Uri</c> and enum types) the values are used as-is.
		/// For list/enumerable-typed properties, the value is a list of the results of recursively applying the mapping process to each element.
		/// For dictionary-typed properties, the value is a <c><![CDATA[Dictionary<string, object?>]]></c> where the key are generated by converting the original keys to strings and the values are the results of recursively applying the mapping process to the corresponding original values.
		/// For other complex POD-typed properties, i.e. for properties of types with public properties, the values are the results of recursively applying the mapping process to the property values.
		/// </remarks>
		public static Dictionary<string, object?> ToDataMappingDictionary(object obj, Func<PropertyInfo, bool> topLevelPropertyFilter) {
			var type = obj.GetType();
			var props = type.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);
			var filteredProps = props.Where(topLevelPropertyFilter);
			return filteredProps.ToDictionary(pi => pi.Name, pi => ObjectToDataMapping(pi.GetValue(obj)));
		}

		/// <summary>
		/// The unfiltered overload of <see cref="ToDataMappingDictionary(object, Func{PropertyInfo, bool})"/> for compatibility.
		/// </summary>
		public static Dictionary<string, object?> ToDataMappingDictionary(object obj) => ToDataMappingDictionary(obj, prop => true);
	}
}
